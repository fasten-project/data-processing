package eu.f4sten.integrationtests.utils;

import eu.fasten.core.data.metadatadb.codegen.tables.Callables;
import eu.fasten.core.data.metadatadb.codegen.tables.Modules;
import eu.fasten.core.data.metadatadb.codegen.tables.PackageVersions;
import eu.fasten.core.dbconnectors.PostgresConnector;
import org.jooq.DSLContext;
import org.jooq.JSONB;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.json.JSONObject;

import java.io.FileReader;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collections;
import java.util.HashSet;

/**
 * This class adds artificial vulnerability into an arbitrary package version and its callables for integration testing.
 * Notes:
 * 1- Uses the Docker compose's metadataDB
 * 2- Uses synthetic jars. See https://github.com/fasten-project/synthetic-testing-jars
 */
public class InjectVulnerability {

    public static void main(String[] args) throws SQLException, IOException, ParseException {

        DSLContext dbContext = PostgresConnector.getDSLContext("jdbc:postgresql://localhost/fasten_java", "fasten", true);
        // The package ID to insert dummy vulnerability into
        long pkgID = 2;

        JSONB pkgIDMetadata = getPkgID(dbContext, pkgID);

        // Read dummy vulnerability from JSON
        var jsonObj = new JSONObject(new JSONParser().parse(new FileReader("plugins/integration-tests/src/main/resources/dummy-cve.json")).toString());

        // Add dummy vulnerability package version's metadata
        injectVulnIntoPkgVer(dbContext, pkgID, pkgIDMetadata, jsonObj);

        var callables = new HashSet<String>();
        var vulnCallableIds = new HashSet<Long>();
        // Add arbitrary callables here
        callables.add("/lib/BasicMotorVehicle.addDirt()%2Fjava.lang%2FVoidType");
        callables.add("/lib/VehicleWash.wash(MotorVehicle)%2Fjava.lang%2FVoidType");
        callables.add("/lib/MotorVehicle.getDirtLevel()%2Fjava.lang%2FIntegerType");

        callables.forEach(c -> {
            var callableID= getCallableID(dbContext, c, new HashSet<>(Collections.singletonList(pkgID)));
            System.out.println(callableID);
            vulnCallableIds.addAll(Collections.singleton(callableID));
        });

        // Inject dummy vulnerability for specified callables
        injectVulnIntoCallable(dbContext, jsonObj, vulnCallableIds);
    }

    private static void injectVulnIntoCallable(DSLContext dbContext, JSONObject jsonObj, HashSet<Long> vulnCallableIds) {
        vulnCallableIds.forEach(id -> {
            var metadataRecord = dbContext.select(Callables.CALLABLES.METADATA)
                    .from(Callables.CALLABLES)
                    .where(Callables.CALLABLES.ID.equal(id))
                    .fetchOne()
                    .component1();
            var metadata = new JSONObject(metadataRecord.data());
            metadata.put("vulnerabilities", new JSONObject());
            ((JSONObject) metadata.get("vulnerabilities")).put(jsonObj.get("id").toString(), jsonObj);
            dbContext.update(Callables.CALLABLES)
                    .set(Callables.CALLABLES.METADATA, JSONB.valueOf(metadata.toString()))
                    .where(Callables.CALLABLES.ID.equal(id))
                    .execute();
        });
    }

    private static void injectVulnIntoPkgVer(DSLContext dbContext, long pkgID, JSONB pkgIDMetadata, JSONObject jsonObj) {
        var metadataJSON = new JSONObject(pkgIDMetadata.data());
        metadataJSON.put("vulnerabilities", new JSONObject());
        ((JSONObject) metadataJSON.get("vulnerabilities")).put(jsonObj.get("id").toString(), jsonObj);
        dbContext.update(PackageVersions.PACKAGE_VERSIONS)
                .set(PackageVersions.PACKAGE_VERSIONS.METADATA, JSONB.valueOf(metadataJSON.toString()))
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgID))
                .execute();
    }

    private static JSONB getPkgID(DSLContext dbContext, long pkgID) {
        return dbContext.select(PackageVersions.PACKAGE_VERSIONS.METADATA)
                    .from(PackageVersions.PACKAGE_VERSIONS)
                    .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgID))
                    .fetchOne()
                    .component1();
    }

    private static long getCallableID(DSLContext dbContext, String fastenUri, HashSet<Long> pkgVersionIds) {
        return dbContext.select(Callables.CALLABLES.ID, Modules.MODULES.PACKAGE_VERSION_ID)
                .from(Callables.CALLABLES)
                .join(Modules.MODULES).on(Modules.MODULES.ID.eq(Callables.CALLABLES.MODULE_ID))
                .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                .and(Modules.MODULES.PACKAGE_VERSION_ID.in(pkgVersionIds))
                .fetch().get(0).component1();
    }
}
